// https://www.nuget.org/packages/Crc32C.NET/  <-- Skimming code I like this one best
// https://github.com/robertvazan/crc32c.net
//--
// https://www.nuget.org/packages/Crc32.NET/
//--
// JavaScript libraries 
//
// RSA: https://www.codeproject.com/Articles/22073/Object-Oriented-JavaScript-Class-Library-in-C-NET
// RSA: https://github.com/travist/jsencrypt
// (no RSA for asmCrypto)
//

Documentation for Basic Encryption
==================================

Password (volatile)
   The owner's clear text password (will never leave the client).
   Password only exists briefly in memory on the client when entered into the password dialogue

RsaPublic (owner property)
   Is the owner's 2048 bit public key, stored in the database. Available as:
   .RsaPublic

RsaPrivate (volatile)
   Is the owner's 2048 bit private key (in-memory value only).

EncryptedRsaPrivate (owner property)
   Is the owner's 2048 bit private key, encrypted using AES with the KeK.
   Stored in the owner's database. Available as:

   (.EncryptedRsaPrivate, IV) = AesCbc.EncryptBytesToBytes_Aes(RsaPrivate, KeyEncryptionKey);

   Note that the IV (128 bit vector) needs to be stored for decryption purposes.

DataEncryptionKey (DeK) [to-be-added] (volatile)
    Is the owner's random 16-byte AES random key used for all data encryption.
    The DataEncryptionKey is necessary so that the owner can change password without
    reencrypting all data.
    
EncryptedDeK [to-be-added] (owner property)
    The encrypted DeK. 
    (isn't XORing DeK and the KEK good enough?)
    Stored in owner's database.

saltPassword (owner property)
   A 16 byte random salt stored in owner's DB. Used to salt the password.

hashPassword (owner property)
    HashPassword = KeyDerivation.Pbkdf2(password, SaltPassword, KeyDerivationPrf.HMACSHA256, CryptographyConstants.ITERATIONS,CryptographyConstants.HASH_SIZE);
    hashPassword is the 16 byte result of hashing the clear text password with the saltPassword.
    The value is stored in the owner's DB.
    When checking if the user entered the correct password, this value, hashed with the 
    nonce will have to match the nonce-hash sent by the client.

saltKek (owner property)
   A 16 byte random salt stored in owner's DB. Used to salt the KeK (done by client)

KeyEncryptionKey / KeK (volatile)
   The KeK is a 16 byte key calculated as follows:
   KeyEncryptionKey = KeyDerivation.Pbkdf2(password, SaltKek, KeyDerivationPrf.HMACSHA256, CryptographyConstants.ITERATIONS, CryptographyConstants.HASH_SIZE);
   The KeK is used for en- / de- cryption of the DeK (XOR) and the RsaPrivate key (AES).

Nonce (owner DB lookup, timeout)
   Is a temporary 16 byte key used to prevent playback when logging in via the client.
   HashedNonceHashedPassword = KeyDerivation.Pbkdf2(Convert.ToBase64String(HashPassword), nonce, KeyDerivationPrf.HMACSHA256, CryptographyConstants.ITERATIONS, CryptographyConstants.HASH_SIZE);

   When the owner enters his password on the client, the password hashed with the saltPassword, then hashed with the nonce.
   The value is sent back to the server. On the server, the nonce is used to hash the hashPassword stored in the database.
   If they match, the password has been entered correctly and the user can login.

---
Password initialization
   Owner enters password on client.
   Client requests Nonce package from server.
   Client receives, saltPassword, saltKek, Nonce.
   Client calculates hashNonce (Hash(Hash(password, saltPassword), Nonce) and hashKek (=KeK)
   Client sends hashNonce, hashKek to the server.
   Server looks up Nonce, checks for timeout.

   Server generates the dataKey as a random 16-byte array, and encrypts it with the KeK (XOR).
   Server generates the RsaPublic & RsaPrivate. Encrypts RsaPrivate using AES() with the KeK

   Stores these two encrypted values.

   [Need to devise a scheme whereby we could generate the RsaKeys on the server before the KeK exists]

Password verify
   Owner enters password on client.
   Client requests Nonce package from server.
   Client receives, saltPassword, saltKek, Nonce.
   Client calculates hashNonce (Hash(Hash(password, saltPassword), Nonce) and hashKek (=KeK)
   Client sends hashNonce, hashKek to the server.
   Server looks up Nonce, checks for timeout.
   Server checks if the owner property for Hash(hashPassword, Nonce) equals the same hashNonce value from the client.

   If a match, server splits the KeK in two halves: It takes the KeK. Generates random 16-byte array. XORs the KeK 
   with the random bytes, stores the XOR'ed KEK in the DB with the random bytes as key. Sets the client cookie("name?") 
   to the 16 random bytes.

   Thus, even without further encryption, the password never leaves client. Playback impossible due to Nonce.
   Kek only exists briefly on the wire and never lives on the server. Server is thus unable to decrypt data
   encrypted with the EncryptedDataKey.

   [TODO: The above transmission from the client to the server will be RSA public key encrypted.
          Server passes its rsaPublicKey to the client, and the client encrypts its return transmission to 
          the server]


Password change
   Enter current & new password
   Verify old password is correct.
   Use current password to decrypt EncryptedRSAPrivate and EncryptedDataKey.
   Calculate new KeK and associated values, store them. 
   Re-encrypt EncryptedRSAPrivate and EncryptedDataKey with the new KeK.
   Invalidate all client keys in DB (each client will need to login again)

Salt update
   Can happen when the password is entered.
   First verify password is correct.
   Then update Salt values, recalculate derived values
   Re-encrypt EncryptedRSAPrivate and EncryptedDataKey with the new KeK.

---

Note that the KeK split in half on client and server

   The KeK is calculated when the password is entered and is sent to the server.
   On the server a 16 byte random value is generated. The value stored on the
   client as a cookie("mynameis?"). The KeK is xor'ed with the cookie value and
   stored in the database. 

   On subsequent web requests, the random 16 byte cookie value XOR'ed with the 
   stored XOR'ed KeK value will result in the KeK. 

======================

High level protocol encryption Identity to Identity

sendPacket(body : byte[], recipient : ?) // Unencrypted
sendPacketEncrypted(body : byte[], recipient : ?) // Encrypted

   A. 4-byte CRC of the recipient's public key (stored in the DB)
   B. 4-byte CRC of the sender's public key (stored in the DB)
   C. Create a header which is encrypted with the recipient's public key:
         16-byte random guid used for encrypting the data.
         [possibly: Calculate Sender's signature on the data in D or at least a CRC32]
   D. Create encrypted data:
        AES encrypted version of the data using the above 16-byte random value as key.

Once sent, only the recipient can access the message by means of their rsaPrivateKey which
allows access to the 16-byte random key which in turns allows AES decryption of the data.
The decrypted data should verify against the sender's signature or CRC32.
The two CRC values is used to make sure it's the right public / private key pair used
(we need to support switching public/private keys if they were compromised).
---
EXAMPLE

Sam wants to send the message "Let's go to Mordor tomorrow." to Frodo.

Sam is online, Frodo is offline:

   - Sam gets Frodo's RSA public key from his host (or locally cached version)
        Sam calculates a CRC32 for the public key 'A' (or gets the cached CRC).
   - Sam generates a random 16 byte message-secret
   - Sam encrypts the data message with AES using the message-secret. Result saved in "D"
   - Sam signs the message with his private key (available via his KeK only).
   - Sam encrypts the 16 byte message-secret and the signature with Frodo's public key into "C"
   - Sam sends Frodo's host a message {A, B, C, D}
      * B = 4 byte CRC for Sam's public key.
        
   - o O o - 

   - The message is now arrivng at Frodo's host:

   - If Frodo's current public key CRC doesn't match CRC-Frodo, reject the message with 
     appropriate error message.

   - Frodo should be sure to have Sam's public key matching CRC-Sam. If not, get it and store it.
   - Frodo's host is currently unable to decrypt the message, stores it "as is" in a queue.
   - A notification can be sent to Frodo's phone saying there is 'something' from Sam.

   - Frodo comes online, the client ½ and host ½ of the KeK join at the server

   - Frodo's host should now process all waiting packages in the queue:
   - Frodo's host can now decrypt C using's Frodo's private key (decrypted with the KeK)
   - The host can decrypt D using the message-secret obtained in C
   - The host can optionally verify Sam's signature using Sam's public key or the CRC32

   - Message is now either stored in clear text or optionally be re-encrypted with AES(DataKey, Message)
     and the queue package can be discarded.

     ===

   - The clear text message could be sent to Frodo's client device.
     More likely the client device should hold an encryption key, the host 
     should encrypt the message with this key, and send the data to the client.

     Should the client's encryption key simply be the DataKey? 


