{"ast":null,"code":"// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined';\n\nfunction noop() {\n  return undefined;\n}\n\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\n\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\n\nfunction difference(array1, array2) {\n  return array1.filter(x => array2.indexOf(x) === -1);\n}\n\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\n\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\n\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\n\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\n\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\n\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\n\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\n\nfunction isError(value) {\n  return value instanceof Error;\n}\n\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\n\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n}\n\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nexport { difference, functionalUpdate, getAbortController, hashQueryKey, hashQueryKeyByOptions, isError, isPlainArray, isPlainObject, isQueryKey, isServer, isValidTimeout, matchMutation, matchQuery, noop, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, partialDeepEqual, partialMatchKey, replaceAt, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };","map":{"version":3,"mappings":"AAYA;AAwDA;MAEaA,QAAQ,GAAG,OAAOC,MAAP,KAAkB;;AAEnC,SAASC,IAAT,GAA2B;EAChC,OAAOC,SAAP;AACD;;AAEM,SAASC,gBAAT,CACLC,OADK,EAELC,KAFK,EAGI;EACT,OAAO,OAAOD,OAAP,KAAmB,UAAnB,GACFA,OAAD,CAAiDC,KAAjD,CADG,GAEHD,OAFJ;AAGD;;AAEM,SAASE,cAAT,CAAwBC,KAAxB,EAAyD;EAC9D,OAAO,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,IAAI,CAAtC,IAA2CA,KAAK,KAAKC,QAA5D;AACD;;AAEM,SAASC,UAAT,CAAuBC,MAAvB,EAAoCC,MAApC,EAAsD;EAC3D,OAAOD,MAAM,CAACE,MAAPF,CAAeG,CAAD,IAAOF,MAAM,CAACG,OAAPH,CAAeE,CAAfF,MAAsB,CAAC,CAA5CD,CAAP;AACD;;AAEM,SAASK,SAAT,CAAsBC,KAAtB,EAAkCC,KAAlC,EAAiDV,KAAjD,EAAgE;EACrE,MAAMW,IAAI,GAAGF,KAAK,CAACG,KAANH,CAAY,CAAZA,CAAb;EACAE,IAAI,CAACD,KAAD,CAAJC,GAAcX,KAAdW;EACA,OAAOA,IAAP;AACD;;AAEM,SAASE,cAAT,CAAwBC,SAAxB,EAA2CC,SAA3C,EAAuE;EAC5E,OAAOC,IAAI,CAACC,GAALD,CAASF,SAAS,IAAIC,SAAS,IAAI,CAAjB,CAATD,GAA+BI,IAAI,CAACC,GAALD,EAAxCF,EAAoD,CAApDA,CAAP;AACD;;AAEM,SAASI,cAAT,CAILC,IAJK,EAKLC,IALK,EAMLC,IANK,EAOK;EACV,IAAI,CAACC,UAAU,CAACH,IAAD,CAAf,EAAuB;IACrB,OAAOA,IAAP;EACD;;EAED,IAAI,OAAOC,IAAP,KAAgB,UAApB,EAAgC;IAC9B,OAAO,EAAE,GAAGC,IAAL;MAAWE,QAAQ,EAAEJ,IAArB;MAA2BK,OAAO,EAAEJ;IAApC,CAAP;EACD;;EAED,OAAO,EAAE,GAAGA,IAAL;IAAWG,QAAQ,EAAEJ;EAArB,CAAP;AACD;;AAEM,SAASM,iBAAT,CAGLN,IAHK,EAILC,IAJK,EAKLC,IALK,EAMK;EACV,IAAIC,UAAU,CAACH,IAAD,CAAd,EAAsB;IACpB,IAAI,OAAOC,IAAP,KAAgB,UAApB,EAAgC;MAC9B,OAAO,EAAE,GAAGC,IAAL;QAAWK,WAAW,EAAEP,IAAxB;QAA8BQ,UAAU,EAAEP;MAA1C,CAAP;IACD;;IACD,OAAO,EAAE,GAAGA,IAAL;MAAWM,WAAW,EAAEP;IAAxB,CAAP;EACD;;EAED,IAAI,OAAOA,IAAP,KAAgB,UAApB,EAAgC;IAC9B,OAAO,EAAE,GAAGC,IAAL;MAAWO,UAAU,EAAER;IAAvB,CAAP;EACD;;EAED,OAAO,EAAE,GAAGA;EAAL,CAAP;AACD;;AAEM,SAASS,eAAT,CAILT,IAJK,EAKLC,IALK,EAMLC,IANK,EAO6B;EAClC,OACEC,UAAU,CAACH,IAAD,CAAVG,GAAmB,CAAC,EAAE,GAAGF,IAAL;IAAWG,QAAQ,EAAEJ;EAArB,CAAD,EAA8BE,IAA9B,CAAnBC,GAAyD,CAACH,IAAI,IAAI,EAAT,EAAaC,IAAb,CAD3D;AAGD;;AAEM,SAASS,uBAAT,CAILV,IAJK,EAKLC,IALK,EAMLC,IANK,EAO6B;EAClC,OACEC,UAAU,CAACH,IAAD,CAAVG,GACI,CAAC,EAAE,GAAGF,IAAL;IAAWM,WAAW,EAAEP;EAAxB,CAAD,EAAiCE,IAAjC,CADJC,GAEI,CAACH,IAAI,IAAI,EAAT,EAAaC,IAAb,CAHN;AAKD;;AAEM,SAASU,UAAT,CACLC,OADK,EAELC,KAFK,EAGI;EACT,MAAM;IACJC,IAAI,GAAG,KADH;IAEJC,KAFI;IAGJC,WAHI;IAIJC,SAJI;IAKJb,QALI;IAMJc;EANI,IAOFN,OAPJ;;EASA,IAAIT,UAAU,CAACC,QAAD,CAAd,EAA0B;IACxB,IAAIW,KAAJ,EAAW;MACT,IAAIF,KAAK,CAACM,SAANN,KAAoBO,qBAAqB,CAAChB,QAAD,EAAWS,KAAK,CAACQ,OAAjB,CAA7C,EAAwE;QACtE,OAAO,KAAP;MACD;IAHH,OAIO,IAAI,CAACC,eAAe,CAACT,KAAK,CAACT,QAAP,EAAiBA,QAAjB,CAApB,EAAgD;MACrD,OAAO,KAAP;IACD;EACF;;EAED,IAAIU,IAAI,KAAK,KAAb,EAAoB;IAClB,MAAMS,QAAQ,GAAGV,KAAK,CAACU,QAANV,EAAjB;;IACA,IAAIC,IAAI,KAAK,QAATA,IAAqB,CAACS,QAA1B,EAAoC;MAClC,OAAO,KAAP;IACD;;IACD,IAAIT,IAAI,KAAK,UAATA,IAAuBS,QAA3B,EAAqC;MACnC,OAAO,KAAP;IACD;EACF;;EAED,IAAI,OAAOL,KAAP,KAAiB,SAAjB,IAA8BL,KAAK,CAACW,OAANX,OAAoBK,KAAtD,EAA6D;IAC3D,OAAO,KAAP;EACD;;EAED,IACE,OAAOF,WAAP,KAAuB,WAAvB,IACAA,WAAW,KAAKH,KAAK,CAACY,KAANZ,CAAYG,WAF9B,EAGE;IACA,OAAO,KAAP;EACD;;EAED,IAAIC,SAAS,IAAI,CAACA,SAAS,CAACJ,KAAD,CAA3B,EAAoC;IAClC,OAAO,KAAP;EACD;;EAED,OAAO,IAAP;AACD;;AAEM,SAASa,aAAT,CACLd,OADK,EAELe,QAFK,EAGI;EACT,MAAM;IAAEZ,KAAF;IAASa,QAAT;IAAmBX,SAAnB;IAA8BV;EAA9B,IAA8CK,OAApD;;EACA,IAAIT,UAAU,CAACI,WAAD,CAAd,EAA6B;IAC3B,IAAI,CAACoB,QAAQ,CAACN,OAATM,CAAiBpB,WAAtB,EAAmC;MACjC,OAAO,KAAP;IACD;;IACD,IAAIQ,KAAJ,EAAW;MACT,IACEc,YAAY,CAACF,QAAQ,CAACN,OAATM,CAAiBpB,WAAlB,CAAZsB,KAA+CA,YAAY,CAACtB,WAAD,CAD7D,EAEE;QACA,OAAO,KAAP;MACD;IALH,OAMO,IAAI,CAACe,eAAe,CAACK,QAAQ,CAACN,OAATM,CAAiBpB,WAAlB,EAA+BA,WAA/B,CAApB,EAAiE;MACtE,OAAO,KAAP;IACD;EACF;;EAED,IACE,OAAOqB,QAAP,KAAoB,SAApB,IACCD,QAAQ,CAACF,KAATE,CAAeG,MAAfH,KAA0B,SAA1BA,KAAyCC,QAF5C,EAGE;IACA,OAAO,KAAP;EACD;;EAED,IAAIX,SAAS,IAAI,CAACA,SAAS,CAACU,QAAD,CAA3B,EAAuC;IACrC,OAAO,KAAP;EACD;;EAED,OAAO,IAAP;AACD;;AAEM,SAASP,qBAAT,CACLhB,QADK,EAELiB,OAFK,EAGG;EACR,MAAMU,MAAM,GAAG,QAAO,QAAPV,mBAAO,CAAEW,cAAT,KAA2BH,YAA1C;EACA,OAAOE,MAAM,CAAC3B,QAAD,CAAb;AACD;AAED;AACA;AACA;AACA;;;AACO,SAASyB,YAAT,CAAsBzB,QAAtB,EAAkD;EACvD,OAAO6B,IAAI,CAACC,SAALD,CAAe7B,QAAf6B,EAAyB,CAACE,CAAD,EAAIC,GAAJ,KAC9BC,aAAa,CAACD,GAAD,CAAbC,GACIC,MAAM,CAACC,IAAPD,CAAYF,GAAZE,EACGE,IADHF,GAEGG,MAFHH,CAEU,CAACI,MAAD,EAASC,GAAT,KAAiB;IACvBD,MAAM,CAACC,GAAD,CAAND,GAAcN,GAAG,CAACO,GAAD,CAAjBD;IACA,OAAOA,MAAP;EAJJ,GAKK,EALLJ,CADJD,GAOID,GARCH,CAAP;AAUD;AAED;AACA;AACA;;;AACO,SAASX,eAAT,CAAyBsB,CAAzB,EAAsCC,CAAtC,EAA4D;EACjE,OAAOC,gBAAgB,CAACF,CAAD,EAAIC,CAAJ,CAAvB;AACD;AAED;AACA;AACA;;;AACO,SAASC,gBAAT,CAA0BF,CAA1B,EAAkCC,CAAlC,EAAmD;EACxD,IAAID,CAAC,KAAKC,CAAV,EAAa;IACX,OAAO,IAAP;EACD;;EAED,IAAI,OAAOD,CAAP,KAAa,OAAOC,CAAxB,EAA2B;IACzB,OAAO,KAAP;EACD;;EAED,IAAID,CAAC,IAAIC,CAALD,IAAU,OAAOA,CAAP,KAAa,QAAvBA,IAAmC,OAAOC,CAAP,KAAa,QAApD,EAA8D;IAC5D,OAAO,CAACP,MAAM,CAACC,IAAPD,CAAYO,CAAZP,EAAeS,IAAfT,CAAqBK,GAAD,IAAS,CAACG,gBAAgB,CAACF,CAAC,CAACD,GAAD,CAAF,EAASE,CAAC,CAACF,GAAD,CAAV,CAA9CL,CAAR;EACD;;EAED,OAAO,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AAEO,SAASU,gBAAT,CAA0BJ,CAA1B,EAAkCC,CAAlC,EAA+C;EACpD,IAAID,CAAC,KAAKC,CAAV,EAAa;IACX,OAAOD,CAAP;EACD;;EAED,MAAMxD,KAAK,GAAG6D,YAAY,CAACL,CAAD,CAAZK,IAAmBA,YAAY,CAACJ,CAAD,CAA7C;;EAEA,IAAIzD,KAAK,IAAKiD,aAAa,CAACO,CAAD,CAAbP,IAAoBA,aAAa,CAACQ,CAAD,CAA/C,EAAqD;IACnD,MAAMK,KAAK,GAAG9D,KAAK,GAAGwD,CAAC,CAACO,MAAL,GAAcb,MAAM,CAACC,IAAPD,CAAYM,CAAZN,EAAea,MAAhD;IACA,MAAMC,MAAM,GAAGhE,KAAK,GAAGyD,CAAH,GAAOP,MAAM,CAACC,IAAPD,CAAYO,CAAZP,CAA3B;IACA,MAAMe,KAAK,GAAGD,MAAM,CAACD,MAArB;IACA,MAAM7D,IAAS,GAAGF,KAAK,GAAG,EAAH,GAAQ,EAA/B;IAEA,IAAIkE,UAAU,GAAG,CAAjB;;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAApB,EAA2BE,CAAC,EAA5B,EAAgC;MAC9B,MAAMZ,GAAG,GAAGvD,KAAK,GAAGmE,CAAH,GAAOH,MAAM,CAACG,CAAD,CAA9B;MACAjE,IAAI,CAACqD,GAAD,CAAJrD,GAAY0D,gBAAgB,CAACJ,CAAC,CAACD,GAAD,CAAF,EAASE,CAAC,CAACF,GAAD,CAAV,CAA5BrD;;MACA,IAAIA,IAAI,CAACqD,GAAD,CAAJrD,KAAcsD,CAAC,CAACD,GAAD,CAAnB,EAA0B;QACxBW,UAAU;MACX;IACF;;IAED,OAAOJ,KAAK,KAAKG,KAAVH,IAAmBI,UAAU,KAAKJ,KAAlCA,GAA0CN,CAA1CM,GAA8C5D,IAArD;EACD;;EAED,OAAOuD,CAAP;AACD;AAED;AACA;AACA;;;AACO,SAASW,mBAAT,CAAgCZ,CAAhC,EAAsCC,CAAtC,EAAqD;EAC1D,IAAKD,CAAC,IAAI,CAACC,CAAND,IAAaC,CAAC,IAAI,CAACD,CAAxB,EAA4B;IAC1B,OAAO,KAAP;EACD;;EAED,KAAK,MAAMD,GAAX,IAAkBC,CAAlB,EAAqB;IACnB,IAAIA,CAAC,CAACD,GAAD,CAADC,KAAWC,CAAC,CAACF,GAAD,CAAhB,EAAuB;MACrB,OAAO,KAAP;IACD;EACF;;EAED,OAAO,IAAP;AACD;;AAEM,SAASM,YAAT,CAAsBtE,KAAtB,EAAsC;EAC3C,OAAO8E,KAAK,CAACC,OAAND,CAAc9E,KAAd8E,KAAwB9E,KAAK,CAACwE,MAANxE,KAAiB2D,MAAM,CAACC,IAAPD,CAAY3D,KAAZ2D,EAAmBa,MAAnE;AACD,C,CAAA;;;AAGM,SAASd,aAAT,CAAuBsB,CAAvB,EAA4C;EACjD,IAAI,CAACC,kBAAkB,CAACD,CAAD,CAAvB,EAA4B;IAC1B,OAAO,KAAP;EAF+C;;;EAMjD,MAAME,IAAI,GAAGF,CAAC,CAACG,WAAf;;EACA,IAAI,OAAOD,IAAP,KAAgB,WAApB,EAAiC;IAC/B,OAAO,IAAP;EAR+C;;;EAYjD,MAAME,IAAI,GAAGF,IAAI,CAACG,SAAlB;;EACA,IAAI,CAACJ,kBAAkB,CAACG,IAAD,CAAvB,EAA+B;IAC7B,OAAO,KAAP;EAd+C;;;EAkBjD,IAAI,CAACA,IAAI,CAACE,cAALF,CAAoB,eAApBA,CAAL,EAA2C;IACzC,OAAO,KAAP;EAnB+C;;;EAuBjD,OAAO,IAAP;AACD;;AAED,SAASH,kBAAT,CAA4BD,CAA5B,EAA6C;EAC3C,OAAOrB,MAAM,CAAC0B,SAAP1B,CAAiB4B,QAAjB5B,CAA0B6B,IAA1B7B,CAA+BqB,CAA/BrB,MAAsC,iBAA7C;AACD;;AAEM,SAASnC,UAAT,CAAoBxB,KAApB,EAAuD;EAC5D,OAAO8E,KAAK,CAACC,OAAND,CAAc9E,KAAd8E,CAAP;AACD;;AAEM,SAASW,OAAT,CAAiBzF,KAAjB,EAA6C;EAClD,OAAOA,KAAK,YAAY0F,KAAxB;AACD;;AAEM,SAASC,KAAT,CAAeC,OAAf,EAA+C;EACpD,OAAO,IAAIC,OAAJ,CAAaC,OAAD,IAAa;IAC9BC,UAAU,CAACD,OAAD,EAAUF,OAAV,CAAVG;EADK,EAAP;AAGD;AAED;AACA;AACA;AACA;;;AACO,SAASC,iBAAT,CAA2BC,QAA3B,EAAiD;EACtDN,KAAK,CAAC,CAAD,CAALA,CAASO,IAATP,CAAcM,QAAdN;AACD;;AAEM,SAASQ,kBAAT,GAA2D;EAChE,IAAI,OAAOC,eAAP,KAA2B,UAA/B,EAA2C;IACzC,OAAO,IAAIA,eAAJ,EAAP;EACD;AACF;;AAEM,SAASC,WAAT,CAGLC,QAHK,EAGwBC,IAHxB,EAGqC7D,OAHrC,EAG+D;EACpE;EACA,IAAIA,OAAO,CAAC8D,WAAR9D,IAAJ,IAAIA,WAAO,CAAC8D,WAAR9D,CAAsB4D,QAAtB5D,EAAgC6D,IAAhC7D,CAAJ,EAA2C;IACzC,OAAO4D,QAAP;EADF,OAEO,IAAI,OAAO5D,OAAO,CAAC+D,iBAAf,KAAqC,UAAzC,EAAqD;IAC1D,OAAO/D,OAAO,CAAC+D,iBAAR/D,CAA0B4D,QAA1B5D,EAAoC6D,IAApC7D,CAAP;EADK,OAEA,IAAIA,OAAO,CAAC+D,iBAAR/D,KAA8B,KAAlC,EAAyC;IAC9C;IACA,OAAO2B,gBAAgB,CAACiC,QAAD,EAAWC,IAAX,CAAvB;EACD;;EACD,OAAOA,IAAP;AACD","names":["isServer","window","noop","undefined","functionalUpdate","updater","input","isValidTimeout","value","Infinity","difference","array1","array2","filter","x","indexOf","replaceAt","array","index","copy","slice","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseMutationArgs","mutationKey","mutationFn","parseFilterArgs","parseMutationFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","hashQueryKey","status","hashFn","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","isPlainArray","aSize","length","bItems","bSize","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","isError","Error","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","getAbortController","AbortController","replaceData","prevData","data","isDataEqual","structuralSharing"],"sources":["/Users/toddmitchell/src/youfoundation/dyc/dotyoucore/Youverse.Provisioning/ClientApp/node_modules/@tanstack/query-core/src/utils.ts"],"sourcesContent":["import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Include or exclude fetching mutations\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined'\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter((x) => array2.indexOf(x) === -1)\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<\n  TOptions extends QueryOptions<any, any, any, TQueryKey>,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | TOptions,\n  arg2?: QueryFunction<any, TQueryKey> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>,\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1) ? [{ ...arg2, queryKey: arg1 }, arg3] : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function parseMutationFilterArgs<\n  TFilters extends MutationFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1)\n      ? [{ ...arg2, mutationKey: arg1 }, arg3]\n      : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, fetching, predicate, mutationKey } = filters\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (\n        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)\n      ) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (\n    typeof fetching === 'boolean' &&\n    (mutation.state.status === 'loading') !== fetching\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function getAbortController(): AbortController | undefined {\n  if (typeof AbortController === 'function') {\n    return new AbortController()\n  }\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual?.(prevData, data)) {\n    return prevData as TData\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n"]},"metadata":{},"sourceType":"module"}