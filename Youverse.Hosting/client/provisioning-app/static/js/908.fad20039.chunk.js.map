{"version":3,"file":"static/js/908.fad20039.chunk.js","mappings":"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","sources":["../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js","../node_modules/use-sync-external-store/shim/index.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../node_modules/@tanstack/query-core/src/mutationObserver.ts","../node_modules/@tanstack/react-query/src/useMutation.ts","../node_modules/@tanstack/query-core/src/queryObserver.ts","../node_modules/@tanstack/react-query/src/QueryErrorResetBoundary.tsx","../node_modules/@tanstack/react-query/src/isRestoring.tsx","../node_modules/@tanstack/react-query/src/useBaseQuery.ts","../node_modules/@tanstack/react-query/src/suspense.ts","../node_modules/@tanstack/react-query/src/errorBoundaryUtils.ts","../node_modules/@tanstack/react-query/src/useQuery.ts","../node_modules/@tanstack/react-query/src/useSyncExternalStore.ts","../node_modules/@tanstack/react-query/src/utils.ts","../node_modules/lodash-es/isObject.js","../node_modules/lodash-es/_freeGlobal.js","../node_modules/lodash-es/_root.js","../node_modules/lodash-es/now.js","../node_modules/lodash-es/_trimmedEndIndex.js","../node_modules/lodash-es/_baseTrim.js","../node_modules/lodash-es/_Symbol.js","../node_modules/lodash-es/_getRawTag.js","../node_modules/lodash-es/_objectToString.js","../node_modules/lodash-es/_baseGetTag.js","../node_modules/lodash-es/isObjectLike.js","../node_modules/lodash-es/isSymbol.js","../node_modules/lodash-es/toNumber.js","../node_modules/lodash-es/debounce.js"],"sourcesContent":["/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var e=require(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","import type { Action, Mutation } from './mutation'\nimport { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type {\n  MutateOptions,\n  MutationObserverBaseResult,\n  MutationObserverResult,\n  MutationObserverOptions,\n} from './types'\nimport { shallowEqualObjects } from './utils'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options\n    this.options = this.client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this,\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables:\n        typeof variables !== 'undefined' ? variables : this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    const result: MutationObserverBaseResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    > = {\n      ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n\n    this.currentResult = result as MutationObserverResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    >\n  }\n\n  private notify(options: NotifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          this.mutateOptions.onSuccess?.(\n            this.currentResult.data!,\n            this.currentResult.variables!,\n            this.currentResult.context!,\n          )\n          this.mutateOptions.onSettled?.(\n            this.currentResult.data!,\n            null,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        } else if (options.onError) {\n          this.mutateOptions.onError?.(\n            this.currentResult.error!,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n          this.mutateOptions.onSettled?.(\n            undefined,\n            this.currentResult.error,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      if (options.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.currentResult)\n        })\n      }\n    })\n  }\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { MutationFunction, MutationKey } from '@tanstack/query-core'\nimport {\n  notifyManager,\n  parseMutationArgs,\n  MutationObserver,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport { shouldThrowError } from './utils'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","import type { DefaultedQueryObserverOptions, RefetchPageFilters } from './types'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\nimport type { Query, QueryState, Action, FetchOptions } from './query'\nimport type { QueryClient } from './queryClient'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch, isCancelledError } from './retryer'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  cache?: boolean\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n\n  private client: QueryClient\n  private currentQuery!: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  private currentQueryInitialState!: QueryState<TQueryData, TError>\n  private currentResult!: QueryObserverResult<TData, TError>\n  private currentResultState?: QueryState<TQueryData, TError>\n  private currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  private previousQueryResult?: QueryObserverResult<TData, TError>\n  private selectError: TError | null\n  private selectFn?: (data: TQueryData) => TData\n  private selectResult?: TData\n  private staleTimeoutId?: ReturnType<typeof setTimeout>\n  private refetchIntervalId?: ReturnType<typeof setInterval>\n  private currentRefetchInterval?: number | false\n  private trackedProps!: Set<keyof QueryObserverResult>\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.trackedProps = new Set()\n    this.selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch()\n      }\n\n      this.updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n    this.currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryOptions(options)\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      typeof options?.isDataEqual !== 'undefined'\n    ) {\n      this.client\n        .getLogger()\n        .error(\n          `The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option`,\n        )\n    }\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this,\n      })\n    }\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.currentRefetchInterval)\n    ) {\n      this.updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.client.getQueryCache().build(this.client, options)\n\n    return this.createResult(query, options)\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.currentQuery\n  }\n\n  remove(): void {\n    this.client.getQueryCache().remove(this.currentQuery)\n  }\n\n  refetch<TPageData>({\n    refetchPage,\n    ...options\n  }: RefetchOptions & RefetchPageFilters<TPageData> = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: { refetchPage },\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.client.defaultQueryOptions(options)\n\n    const query = this.client\n      .getQueryCache()\n      .build(this.client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.currentResult\n    })\n  }\n\n  private executeFetch(\n    fetchOptions?: ObserverFetchOptions,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  private updateStaleTimeout(): void {\n    this.clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.currentResult.dataUpdatedAt,\n      this.options.staleTime,\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  private computeRefetchInterval() {\n    return typeof this.options.refetchInterval === 'function'\n      ? this.options.refetchInterval(this.currentResult.data, this.currentQuery)\n      : this.options.refetchInterval ?? false\n  }\n\n  private updateRefetchInterval(nextInterval: number | false): void {\n    this.clearRefetchInterval()\n\n    this.currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.currentRefetchInterval) ||\n      this.currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.executeFetch()\n      }\n    }, this.currentRefetchInterval)\n  }\n\n  private updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval(this.computeRefetchInterval())\n  }\n\n  private clearStaleTimeout(): void {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId)\n      this.staleTimeoutId = undefined\n    }\n  }\n\n  private clearRefetchInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.currentQuery\n    const prevOptions = this.options\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.currentResultState\n    const prevResultOptions = this.currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.currentQueryInitialState\n    const prevQueryResult = queryChange\n      ? this.currentResult\n      : this.previousQueryResult\n\n    const { state } = query\n    let { dataUpdatedAt, error, errorUpdatedAt, fetchStatus, status } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!dataUpdatedAt) {\n          status = 'loading'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Keep previous data if needed\n    if (\n      options.keepPreviousData &&\n      !state.dataUpdatedAt &&\n      prevQueryResult?.isSuccess &&\n      status !== 'error'\n    ) {\n      data = prevQueryResult.data\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt\n      status = prevQueryResult.status\n      isPreviousData = true\n    }\n    // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.selectFn\n      ) {\n        data = this.selectResult\n      } else {\n        try {\n          this.selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.selectResult = data\n          this.selectError = null\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError)\n          }\n          this.selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'loading'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (options.placeholderData as PlaceholderDataFunction<TQueryData>)()\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.selectError = null\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError)\n            }\n            this.selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = replaceData(prevResult?.data, placeholderData, options) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError as any\n      data = this.selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n    const isLoading = status === 'loading'\n    const isError = status === 'error'\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.currentQuery, this.options)\n    this.currentResultState = this.currentQuery.state\n    this.currentResultOptions = this.options\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = { cache: true }\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n\n      if (\n        notifyOnChangeProps === 'all' ||\n        (!notifyOnChangeProps && !this.trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(notifyOnChangeProps ?? this.trackedProps)\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  private updateQuery(): void {\n    const query = this.client.getQueryCache().build(this.client, this.options)\n\n    if (query === this.currentQuery) {\n      return\n    }\n\n    const prevQuery = this.currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.currentQuery = query\n    this.currentQueryInitialState = query.state\n    this.previousQueryResult = this.currentResult\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(action: Action<TData, TError>): void {\n    const notifyOptions: NotifyOptions = {}\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true\n    }\n\n    this.updateResult(notifyOptions)\n\n    if (this.hasListeners()) {\n      this.updateTimers()\n    }\n  }\n\n  private notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        this.options.onSuccess?.(this.currentResult.data!)\n        this.options.onSettled?.(this.currentResult.data!, null)\n      } else if (notifyOptions.onError) {\n        this.options.onError?.(this.currentResult.error!)\n        this.options.onSettled?.(undefined, this.currentResult.error!)\n      }\n\n      // Then trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated',\n        })\n      }\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: typeof options['refetchOnMount'] &\n    typeof options['refetchOnWindowFocus'] &\n    typeof options['refetchOnReconnect'],\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n","import * as React from 'react'\n\n// CONTEXT\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","import * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","import * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { QueryKey, QueryObserver } from '@tanstack/query-core'\nimport { notifyManager } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { UseBaseQueryOptions } from './types'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { ensureStaleTime, shouldSuspend, fetchOptimistic } from './suspense'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  ensureStaleTime(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      useErrorBoundary: defaultedOptions.useErrorBoundary,\n      query: observer.getCurrentQuery(),\n    })\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","import type { DefaultedQueryObserverOptions } from '@tanstack/query-core'\nimport type { QueryObserver } from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\nimport type { QueryObserverResult } from '@tanstack/query-core'\nimport type { QueryKey } from '@tanstack/query-core'\n\nexport const ensureStaleTime = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => defaultedOptions?.suspense && willFetch(result, isRestoring)\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer\n    .fetchOptimistic(defaultedOptions)\n    .then(({ data }) => {\n      defaultedOptions.onSuccess?.(data as TData)\n      defaultedOptions.onSettled?.(data, null)\n    })\n    .catch((error) => {\n      errorResetBoundary.clearReset()\n      defaultedOptions.onError?.(error)\n      defaultedOptions.onSettled?.(undefined, error)\n    })\n","import type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  UseErrorBoundary,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\nimport * as React from 'react'\nimport { shouldThrowError } from './utils'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  useErrorBoundary: UseErrorBoundary<\n    TQueryFnData,\n    TError,\n    TQueryData,\n    TQueryKey\n  >\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(useErrorBoundary, [result.error, query])\n  )\n}\n","import type { QueryFunction, QueryKey } from '@tanstack/query-core'\nimport { parseQueryArgs, QueryObserver } from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n","// Temporary workaround due to an issue with react-native uSES - https://github.com/TanStack/query/pull/3601\nimport { useSyncExternalStore as uSES } from 'use-sync-external-store/shim/index.js'\n\nexport const useSyncExternalStore = uSES\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n","import root from './_root.js';\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nexport default now;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nexport default trimmedEndIndex;\n","import trimmedEndIndex from './_trimmedEndIndex.js';\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nexport default baseTrim;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n","import baseTrim from './_baseTrim.js';\nimport isObject from './isObject.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nexport default toNumber;\n","import isObject from './isObject.js';\nimport now from './now.js';\nimport toNumber from './toNumber.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nexport default debounce;\n"],"names":["e","require","k","Object","is","a","b","l","useState","m","useEffect","n","useLayoutEffect","p","useDebugValue","r","getSnapshot","value","d","f","u","window","document","createElement","inst","c","g","exports","useSyncExternalStore","module","_objectWithoutProperties","source","excluded","key","i","target","sourceKeys","keys","length","indexOf","getOwnPropertySymbols","sourceSymbolKeys","prototype","propertyIsEnumerable","call","MutationObserver","constructor","client","options","setOptions","bindMethods","updateResult","this","mutate","bind","reset","prevOptions","defaultMutationOptions","shallowEqualObjects","getMutationCache","notify","type","mutation","currentMutation","observer","onUnsubscribe","listeners","removeObserver","onMutationUpdate","action","notifyOptions","onSuccess","onError","getCurrentResult","currentResult","undefined","variables","mutateOptions","build","addObserver","execute","state","getDefaultState","result","isLoading","status","isSuccess","isError","isIdle","notifyManager","_this$mutateOptions$o","data","context","onSettled","_this$mutateOptions$o3","error","forEach","listener","Subscribable","useMutation","arg1","arg2","arg3","parseMutationArgs","queryClient","useQueryClient","React","onStoreChange","subscribe","catch","noop","shouldThrowError","useErrorBoundary","mutateAsync","QueryObserver","trackedProps","Set","selectError","remove","refetch","onSubscribe","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","prevQuery","defaultQueryOptions","getQueryCache","query","enabled","Error","queryKey","updateQuery","mounted","hasListeners","shouldFetchOptionally","staleTime","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","createResult","trackResult","trackedResult","defineProperty","configurable","enumerable","get","add","getCurrentQuery","refetchPage","fetch","meta","fetchOptimistic","defaultedOptions","isFetchingOptimistic","then","fetchOptions","cancelRefetch","_fetchOptions$cancelR","promise","throwOnError","isServer","isStale","isValidTimeout","timeout","timeUntilStale","dataUpdatedAt","staleTimeoutId","setTimeout","refetchInterval","_this$options$refetch","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","focusManager","clearTimeout","clearInterval","prevResult","prevResultState","currentResultState","prevResultOptions","currentResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","errorUpdatedAt","fetchStatus","isPreviousData","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","canFetch","networkMode","keepPreviousData","select","selectFn","selectResult","replaceData","process","placeholderData","Date","now","isFetching","isInitialLoading","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","nextResult","defaultNotifyOptions","cache","notifyOnChangeProps","size","includedProps","some","typedKey","has","shouldNotifyListeners","onQueryUpdate","manual","isCancelledError","retryOnMount","shouldLoadOnMount","refetchOnMount","field","suspense","isStaleByTime","createValue","isReset","clearReset","QueryErrorResetBoundaryContext","IsRestoringContext","Provider","useBaseQuery","Observer","isRestoring","errorResetBoundary","ensureStaleTime","ensurePreventErrorBoundaryRetry","useClearResetErrorBoundary","willFetch","shouldSuspend","getHasError","useQuery","parseQueryArgs","uSES","_useErrorBoundary","params","global","freeSelf","self","freeGlobal","Function","root","reWhitespace","string","index","test","charAt","reTrimStart","slice","trimmedEndIndex","replace","objectProto","hasOwnProperty","nativeObjectToString","toString","symToStringTag","Symbol","isOwn","tag","unmasked","getRawTag","objectToString","isObjectLike","baseGetTag","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","isSymbol","isObject","other","valueOf","baseTrim","isBinary","nativeMax","Math","max","nativeMin","min","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","apply","leadingEdge","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","arguments","toNumber","cancel","flush"],"sourceRoot":""}