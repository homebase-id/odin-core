<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title></title>
    <script src="auth.js"></script>
</head>

<body>
<p>Run this as a file in your browser to test Web Crypto API functions are compatible with C# counterparts.</p>
<p>Open the console</p>
<p>pbkdf2   result: <div id="test1">calculating</div></p><br />
<p>aes-cbc  result: <div id="test2">calculating</div></p><br />
<p>RSA-OAEP result: <div id="test3">calculating</div></p><br />
</body>
</html>

<script>
    // Validate that the implementation returns the same as in C# / .net core
    async function test_pbkdf2() {
        console.log("========  TEST PBKDF2 CROSS PLATFORM===============");
        const areEqual = (first, second) =>
            first.length === second.length && first.every((value, index) => value === second[index]);

        var salt = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);
        var expected = new Uint8Array([162, 146, 244, 243, 106, 138, 115, 194, 11, 233, 94, 27, 79, 215, 36, 204]);
        const iterations = 100000;

        console.log("Hashing");
        var hashed = await pbkdf2("EnSøienØ", salt, "SHA-256", iterations, 16);

        console.log("Compare :  ", hashed, " ?= ", expected);

        if (!areEqual(expected, hashed))
            throw "Failed pbkdf2";
    }


    // DONT USE THIS FUNCTION, ONLY FOR TESTING
    async function AesCbc_EncryptIv(u8aData, u8aKey, u8aIv) {
        let key = await crypto.subtle.importKey(
            "raw",
            u8aKey,
            {   //this is the algorithm options
                name: "AES-CBC",
            },
            false, //whether the key is extractable (i.e. can be used in exportKey)
            ["encrypt", "decrypt"] //can be "encrypt", "decrypt", "wrapKey", or "unwrapKey"
        );

        let cipher = await crypto.subtle.encrypt(
            {
                name: "AES-CBC",
                iv: u8aIv,
            },
            key, //from generateKey or importKey above
            u8aData //ArrayBuffer of data you want to encrypt
        );

        return { cipher: (new Uint8Array(cipher)), iv: u8aIv };
    }

    // Validate that the implementation returns the same as in C# / .net core
    async function test_AesCbc() {
        console.log("========  TEST AES CROSS PLATFORM===============");

        const areEqual = (first, second) =>
            first.length === second.length && first.every((value, index) => value === second[index]);


        // First do a round-trip encrypt / decrypt
        //
        //
        var key = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);
        var iv = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);
        var testData = new Uint8Array([162, 146, 244, 255, 127, 128, 0, 42, 7, 0]);
        var expectedCipher = new Uint8Array([88, 229, 118, 198, 59, 215, 71, 157, 114, 102, 238, 38, 203, 251, 48, 157]);

        AesCbc_EncryptIv(testData, key, iv).then(myobj => {
            console.log("Cipher " + myobj.cipher);
            console.log("Expected " + expectedCipher);
            console.log("Cipher and .NET AreEqual? " + areEqual(expectedCipher, myobj.cipher));

            AesCbc_Decrypt(myobj.cipher, key, myobj.iv).then(u8aDecrypted => {
                console.log("Original ", testData, " ?= ", u8aDecrypted);

                if (!areEqual(testData, u8aDecrypted))
                    throw "AES cross platform failed";
                console.log(" - - AES done - -");
            });
        });
    }


    async function test_rsa_xplatformn()
    {
        console.log("========  TEST RSA CROSS PLATFORM===============");

        publicKey64 = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6Tt75Wgd7iVOlFk9sTl/+d/oiiMPNH5NtHaK6uOPE1GRCSXWbvvY46+vrgNIk3DZCDSPCk26e0U+AvB/mwtZFaqcRrg3rbO2jcGQWybYZdTA+UqQNVi1BSxRCRlFptGoM+pdGnnAG8o80VwWZlryUPiMXM2FF/BhHSOxDoMfXgFKJnxc+4Mvdzu5qYA+/ivjgCmT+zUhb00eSWnCCgnB4SXRFP/VZB2isH/ovfJ6kTGDE+e1Ct3gQD6mst0CcSe9YvXhYhADqjOO5nLIq4b+BXoM18ce4qy9t75/AmdW9PdOx7CikVDHNrhVwYAt9rNTnftW9yAPmUX9pGydoAlyqQIDAQAB";
        privateKey64 = "";

        let my200 = "01234567890123456789012345678901234567890123456789" + "01234567890123456789012345678901234567890123456789" +
            "01234567890123456789012345678901234567890123456789";


        var key = await RsaImportKey(publicKey64);
        console.log("RSA Public Key :", key);
        var cipher = await RsaOaepEncrypt(key, my200);
        console.log("RSA Public Key encryption Cipher:", cipher);
        console.log("RSA Public Key encryption Cipher base64:", arrayBufferToBase64(cipher));
        console.log(" - - DONE - -");
    }

    async function test_sha_xplatform() {
        console.log("========  TEST SHA CROSS PLATFORM===============");

        var testData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);
        var sha = await sha256(testData);
        console.log("The SHA is:", sha);
        console.log(" - - DONE - -");
    }

    async function test_crc() {
        // CRC
        console.log("========  TEST CRC CROSS PLATFORM ===============");
        var crc = crc32c("bear sandwich");
        console.log("CRC32C = ", crc, " expected ", 3711466352);
        if (crc != 3711466352)
            throw "CRC not cross platforn";
    }

    async function run_tests() {
        // SHA
        var q = await test_sha_xplatform();

        // RSA
        var q = await test_rsa_xplatformn();

        // CRC
        var q = await test_crc();

        // PBKDF2
        var q = await test_pbkdf2();

        // AES
        var q = await test_AesCbc();
    }

    run_tests();

</script>


