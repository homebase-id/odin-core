{"version":3,"file":"static/js/713.b3e692bd.chunk.js","mappings":"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","sources":["provider/transit/ExternalProfileDataProvider.ts","provider/contact/ContactSourceProvider.ts","hooks/contacts/useContact.ts","provider/connections/CircleNetworkProvider.ts","provider/contact/ContactProvider.ts","provider/contact/ContactTypes.ts","provider/transit/ExternalMediaProvider.ts","provider/transit/TransitProvider.ts"],"sourcesContent":["import {\n  FileQueryParams,\n  AttributeConfig,\n  BuiltInProfiles,\n  getTargetDriveFromProfileId,\n  AttributeFile,\n} from '@youfoundation/dotyoucore-js';\nimport { OwnerProviderBase } from '../OwnerProviderBase';\n\nimport TransitProvider from './TransitProvider';\n\n// interface ExternalDataProviderOptions extends ProviderOptions {\n//   driveProvider: DriveProvider;\n// }\n\nexport default class ExternalDataProvider extends OwnerProviderBase {\n  private static instance: ExternalDataProvider;\n  private transitProvider: TransitProvider;\n\n  constructor(sharedSecret: Uint8Array) {\n    super(sharedSecret);\n\n    this.transitProvider = TransitProvider.getInstance(sharedSecret);\n  }\n\n  async getProfileAttributes(dotYouId: string, attributeType?: string): Promise<AttributeFile[]> {\n    const profileId = BuiltInProfiles.StandardProfileId;\n    const targetDrive = getTargetDriveFromProfileId(profileId);\n\n    const queryParams: FileQueryParams = {\n      targetDrive: targetDrive,\n      fileType: [AttributeConfig.AttributeFileType],\n      tagsMatchAll: attributeType ? [attributeType] : undefined,\n    };\n\n    const result = await this.transitProvider.QueryBatch(dotYouId, queryParams);\n\n    //sort where lowest number is higher priority (!! sort happens in place)\n    const searchResults = result.searchResults.sort((a, b) => {\n      return a.priority - b.priority;\n    });\n\n    return (\n      await Promise.all(\n        searchResults.map(async (dsr) => {\n          const attr: AttributeFile = {\n            id: '',\n            type: attributeType,\n            sectionId: '',\n            priority: -1,\n            data: null,\n            profileId: profileId,\n            acl: dsr.serverMetadata?.accessControlList,\n          };\n\n          const attrPayLoad: AttributeFile = await this.transitProvider.GetPayload<AttributeFile>(\n            dotYouId,\n            targetDrive,\n            dsr.fileId,\n            dsr.fileMetadata,\n            dsr.sharedSecretEncryptedKeyHeader,\n            result.includeMetadataHeader\n          );\n\n          return {\n            ...attr,\n            ...attrPayLoad,\n          };\n        })\n      )\n    ).filter((item) => !!item);\n  }\n\n  public static getInstance(sharedSecret): ExternalDataProvider {\n    if (!ExternalDataProvider.instance) {\n      ExternalDataProvider.instance = new ExternalDataProvider(sharedSecret);\n    }\n\n    return ExternalDataProvider.instance;\n  }\n}\n","import {\n  AttributeDefinitions,\n  MinimalProfileFields,\n  LocationFields,\n  PhoneFields,\n  BirthdayFields,\n  getTargetDriveFromProfileId,\n  BuiltInProfiles,\n  DataUtil,\n  PublicClient,\n  ApiType,\n} from '@youfoundation/dotyoucore-js';\nimport { CircleNetworkProvider } from '../connections/CircleNetworkProvider';\nimport { CircleNetworkRequestProvider } from '../connections/CircleNetworkRequestProvider';\nimport { OwnerProviderBase } from '../OwnerProviderBase';\nimport { ExternalMediaProvider } from '../transit/ExternalMediaProvider';\nimport ExternalDataProvider from '../transit/ExternalProfileDataProvider';\nimport { RawContact } from './ContactTypes';\n\n//Handles fetching and parsing of Contact Source data\nexport class ContactSourceProvider extends OwnerProviderBase {\n  private static instance: ContactSourceProvider;\n  private externalDataProvider: ExternalDataProvider;\n  private externalMediaProvider: ExternalMediaProvider;\n  private circleNetworkProvider: CircleNetworkProvider;\n  private circleNetworkRequestProvider: CircleNetworkRequestProvider;\n\n  constructor(sharedSecret: Uint8Array | undefined) {\n    if (!sharedSecret) {\n      throw '[ContactSourceProvider] Shared Secret is required';\n    }\n    super(sharedSecret);\n\n    this.externalDataProvider = ExternalDataProvider.getInstance(sharedSecret);\n    this.circleNetworkProvider = CircleNetworkProvider.getInstance(sharedSecret);\n    this.circleNetworkRequestProvider = CircleNetworkRequestProvider.getInstance(sharedSecret);\n    this.externalMediaProvider = ExternalMediaProvider.getInstance(sharedSecret);\n  }\n\n  async fetchConnectionInfo(dotYouId: string): Promise<RawContact | undefined> {\n    const [connectionContactData, contactFromTransit] = await Promise.all([\n      this.circleNetworkProvider.getConnectionInfo(dotYouId, true),\n      this.queryConnectionAttributes(dotYouId),\n    ]);\n\n    if (connectionContactData) {\n      if (connectionContactData?.originalContactData) {\n        return {\n          name: {\n            givenName: connectionContactData.originalContactData.givenName,\n            surname: connectionContactData.originalContactData.surname,\n          },\n          image: await this.getPhotoDataFromPublic(\n            dotYouId,\n            connectionContactData.originalContactData.imageId\n          ),\n          ...contactFromTransit,\n          source: 'contact',\n        };\n      } else {\n        return contactFromTransit;\n      }\n    }\n  }\n\n  async queryConnectionAttributes(dotYouId: string): Promise<RawContact | undefined> {\n    try {\n      const [name, phone, location, birthday, photo] = await Promise.all([\n        (\n          await this.externalDataProvider.getProfileAttributes(\n            dotYouId,\n            AttributeDefinitions.Name.type\n          )\n        )?.[0],\n        (\n          await this.externalDataProvider.getProfileAttributes(\n            dotYouId,\n            AttributeDefinitions.PhoneNumber.type\n          )\n        )?.[0],\n        (\n          await this.externalDataProvider.getProfileAttributes(\n            dotYouId,\n            AttributeDefinitions.Location.type\n          )\n        )?.[0],\n        (\n          await this.externalDataProvider.getProfileAttributes(\n            dotYouId,\n            AttributeDefinitions.Birthday.type\n          )\n        )?.[0],\n        (\n          await this.externalDataProvider.getProfileAttributes(\n            dotYouId,\n            AttributeDefinitions.Photo.type\n          )\n        )?.[0],\n      ]);\n\n      return {\n        source: 'contact',\n        name: {\n          givenName: name?.data?.[MinimalProfileFields.GivenNameId],\n          surname: name?.data?.[MinimalProfileFields.SurnameId],\n        },\n        location: {\n          city: location?.data?.[LocationFields.City],\n          country: location?.data?.[LocationFields.Country],\n        },\n        phone: { number: phone?.data?.[PhoneFields.PhoneNumber] },\n        birthday: { date: birthday?.data?.[BirthdayFields.Date] },\n        image: photo\n          ? await this.queryConnectionPhotoData(\n              dotYouId,\n              photo.data[MinimalProfileFields.ProfileImageId]\n            )\n          : undefined,\n      };\n    } catch (ex) {\n      return undefined;\n    }\n  }\n\n  async queryConnectionPhotoData(dotYouId: string, profileImageId: string) {\n    const imageData = await this.externalMediaProvider.getDecryptedImageData(\n      dotYouId,\n      getTargetDriveFromProfileId(BuiltInProfiles.StandardProfileId),\n      profileImageId\n    );\n\n    return {\n      pixelWidth: imageData.pixelWidth,\n      pixelHeight: imageData.pixelHeight,\n      contentType: imageData.contentType,\n      content: DataUtil.uint8ArrayToBase64(new Uint8Array(imageData.content)),\n    };\n  }\n\n  async fetchPendingInfo(\n    dotYouId: string,\n    loadPendingProfilePicture: boolean\n  ): Promise<RawContact | undefined> {\n    try {\n      const pendingContactData = await this.circleNetworkRequestProvider.getPendingRequest(\n        dotYouId\n      );\n\n      // TODO: Don't think this check should be needed; Pending request is also returning sent ones\n      if (pendingContactData.senderDotYouId === dotYouId) {\n        if (pendingContactData?.contactData) {\n          return {\n            name: {\n              givenName: pendingContactData.contactData.givenName,\n              surname: pendingContactData.contactData.surname,\n            },\n            image: loadPendingProfilePicture\n              ? await this.getPhotoDataFromPublic(dotYouId, pendingContactData.contactData.imageId)\n              : undefined,\n\n            source: 'pending',\n          };\n        }\n      }\n    } catch (ex) {\n      return;\n    }\n  }\n\n  async fetchDataFromPublic(\n    dotYouId: string,\n    loadPendingProfilePicture: boolean\n  ): Promise<RawContact | undefined> {\n    const client = new PublicClient({ api: ApiType.YouAuth, root: dotYouId });\n    const rawData = await client.fileReadOnlyProvider.GetFile('public.json');\n\n    const nameAttr = rawData?.get('name')?.[0];\n    const photoRefAttr = rawData?.get('photo')?.[0];\n    const photoFile = rawData?.get(photoRefAttr?.payload?.data?.profileImageId)?.[0] ?? undefined;\n\n    if (!photoFile || !loadPendingProfilePicture) {\n      return {\n        name:\n          nameAttr?.payload?.data.givenName || nameAttr?.payload?.data.surname\n            ? {\n                givenName: nameAttr.payload.data.givenName,\n                surname: nameAttr.payload.data.surname,\n              }\n            : undefined,\n        image: undefined,\n        source: 'public',\n      };\n    }\n\n    const previewThumbnail = photoFile.additionalThumbnails.reduce(\n      (prevVal, curValue) => {\n        if (prevVal.pixelWidth < curValue.pixelWidth && curValue.pixelWidth <= 250) {\n          return curValue;\n        }\n        return prevVal;\n      },\n      { ...photoFile.header.fileMetadata.appData.previewThumbnail, pixelWidth: 20, pixelHeight: 20 }\n    );\n\n    return {\n      name:\n        nameAttr.payload.data.givenName || nameAttr.payload.data.surname\n          ? {\n              givenName: nameAttr.payload.data.givenName,\n              surname: nameAttr.payload.data.surname,\n            }\n          : undefined,\n      image: {\n        pixelWidth: previewThumbnail.pixelWidth,\n        pixelHeight: previewThumbnail.pixelHeight,\n        contentType: previewThumbnail.contentType,\n        content: previewThumbnail.content.toString(),\n      },\n      source: 'public',\n    };\n  }\n\n  async getPhotoDataFromPublic(dotYouId: string, imageFileId: string) {\n    const client = new PublicClient({ api: ApiType.YouAuth, root: dotYouId });\n    const rawData = await client.fileReadOnlyProvider.GetFile('public.json');\n\n    const photoData = rawData?.get(imageFileId)?.[0];\n\n    if (!photoData) {\n      return;\n    }\n\n    const previewThumbnail = photoData.additionalThumbnails.reduce(\n      (prevVal, curValue) => {\n        if (prevVal.pixelWidth < curValue.pixelWidth && curValue.pixelWidth <= 250) {\n          return curValue;\n        }\n        return prevVal;\n      },\n      { ...photoData.header.fileMetadata.appData.previewThumbnail, pixelWidth: 20, pixelHeight: 20 }\n    );\n\n    return {\n      pixelWidth: previewThumbnail.pixelWidth,\n      pixelHeight: previewThumbnail.pixelHeight,\n      contentType: previewThumbnail.contentType,\n      content: previewThumbnail.content.toString(),\n    };\n  }\n\n  public static getInstance(sharedSecret): ContactSourceProvider {\n    if (!ContactSourceProvider.instance) {\n      ContactSourceProvider.instance = new ContactSourceProvider(sharedSecret);\n    }\n\n    return ContactSourceProvider.instance;\n  }\n}\n","import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';\nimport { DataUtil } from '@youfoundation/dotyoucore-js';\nimport { ContactProvider } from '../../provider/contact/ContactProvider';\nimport { ContactSourceProvider } from '../../provider/contact/ContactSourceProvider';\nimport { ContactFile, ContactVm, RawContact } from '../../provider/contact/ContactTypes';\nimport useAuth from '../auth/useAuth';\n\nconst useContact = ({\n  dotYouId,\n  id,\n  loadPendingProfilePicture,\n}: {\n  dotYouId?: string;\n  id?: string;\n  loadPendingProfilePicture?: boolean;\n}) => {\n  const { getSharedSecret } = useAuth();\n  const contactProvider = ContactProvider.getInstance(getSharedSecret());\n  const contactSourceProvider = ContactSourceProvider.getInstance(getSharedSecret());\n\n  const queryClient = useQueryClient();\n\n  const fetchSingle = async ({\n    dotYouId,\n    id,\n    loadPendingProfilePicture,\n  }: {\n    dotYouId: string;\n    id: string;\n    loadPendingProfilePicture?: boolean;\n  }): Promise<ContactVm | undefined> => {\n    if (!dotYouId) {\n      if (!id) {\n        return;\n      }\n\n      //Direct fetch with id:\n      const directContact = await contactProvider.getContactByUniqueId(id);\n      return directContact;\n    }\n\n    // Direct fetch with dotYouId:\n    const contactBookContact = await contactProvider.getContactByUniqueId(\n      DataUtil.toGuidId(dotYouId)\n    );\n    if (contactBookContact) {\n      return contactBookContact;\n    }\n\n    // If no contact in the contact book:\n    // Get contact data from connection single:\n    const connectionInfo = await contactSourceProvider.fetchConnectionInfo(dotYouId);\n    if (connectionInfo) {\n      // => And automatically push into the Contact\n      const connectionContact = await contactProvider.saveContact({\n        ...connectionInfo,\n        dotYouId: dotYouId,\n      });\n\n      return parseContact(connectionContact);\n    }\n\n    console.debug(\n      `Contact book and connection detail is empty for ${dotYouId}, gone hunting for best fallback`\n    );\n\n    let returnContact;\n\n    // Else fallback to:\n    // Get contact data from pending single:\n    if (!returnContact) {\n      const pendingInfo =\n        (await contactSourceProvider.fetchPendingInfo(dotYouId, loadPendingProfilePicture)) ??\n        undefined;\n      returnContact = pendingInfo ? { ...contactBookContact, ...pendingInfo } : returnContact;\n    }\n\n    // Get contact data from public.json\n    if (!returnContact) {\n      const publicContact = await contactSourceProvider.fetchDataFromPublic(\n        dotYouId,\n        loadPendingProfilePicture\n      );\n      returnContact = publicContact ? { ...contactBookContact, ...publicContact } : returnContact;\n    }\n\n    if (returnContact) {\n      // Don't save contacts if we weren't allowed to fetch images\n      if (loadPendingProfilePicture) {\n        // => And automatically push into the Contact\n        const savedReturnedContact = await contactProvider.saveContact({\n          ...returnContact,\n          dotYouId: dotYouId,\n        });\n\n        return parseContact(savedReturnedContact);\n      } else {\n        return parseContact(returnContact);\n      }\n    }\n\n    return undefined;\n  };\n\n  const refresh = async ({ contact }: { contact: ContactFile }) => {\n    if (!contact.id || !contact.dotYouId) {\n      console.warn('Missing data to fetch new contact data reliable');\n      return;\n    }\n\n    let newContact: ContactFile;\n\n    const connectionInfo =\n      (await contactSourceProvider.fetchConnectionInfo(contact.dotYouId)) ?? undefined;\n    newContact = connectionInfo ? { ...contact, ...connectionInfo } : undefined;\n\n    if (newContact) {\n      newContact = await contactProvider.saveContact({\n        ...newContact,\n        dotYouId: contact.dotYouId,\n      });\n\n      return;\n    } else {\n      const publicContact = await contactSourceProvider.fetchDataFromPublic(dotYouId, true);\n      newContact = await contactProvider.saveContact({\n        ...publicContact,\n        dotYouId: dotYouId,\n      });\n    }\n  };\n\n  return {\n    fetch: useQuery(\n      ['contact', dotYouId ?? id, loadPendingProfilePicture],\n      () =>\n        fetchSingle({\n          dotYouId: dotYouId,\n          id: id,\n          loadPendingProfilePicture: loadPendingProfilePicture,\n        }),\n      {\n        refetchOnWindowFocus: false,\n        onError: (err) => console.error(err),\n        retry: false,\n      }\n    ),\n    refresh: useMutation(refresh, {\n      onMutate: async (newContact) => {\n        await queryClient.cancelQueries(['contact', dotYouId ?? id]);\n\n        // Update single attribute\n        const previousContact = queryClient.getQueryData(['contact', dotYouId ?? id]);\n        // TODO: fix, can't be set as the incoming new isn't the refresh data\n        queryClient.setQueryData(['contact', dotYouId ?? id], newContact);\n\n        return { previousContact, newContact };\n      },\n      onError: (err, _newAttr, context) => {\n        console.error(err);\n\n        // Revert local caches to what they were\n        queryClient.setQueryData(['contact', dotYouId ?? id], context.previousContact);\n      },\n      onSettled: () => {\n        queryClient.invalidateQueries(['contact', dotYouId]);\n        queryClient.invalidateQueries(['contact', id]);\n      },\n    }),\n  };\n};\n\nexport const parseContact = (contact: RawContact): ContactVm => {\n  let imageUrl;\n  if (contact.image && !contact.imageFileId) {\n    const buffer = DataUtil.base64ToUint8Array(contact.image.content);\n    imageUrl = window.URL.createObjectURL(new Blob([buffer], { type: contact.image.contentType }));\n  }\n\n  const { id, name, location, phone, birthday, imageFileId, dotYouId, source } = contact;\n\n  return {\n    id,\n    name,\n    location,\n    phone,\n    birthday,\n    imageFileId,\n    imageUrl,\n    dotYouId,\n    source,\n  };\n};\n\nexport default useContact;\n","import { ConnectionInfo, DotYouIdRequest, DotYouProfile } from './CircleDataTypes';\nimport { PagedResult, PagingOptions } from '@youfoundation/dotyoucore-js';\nimport { OwnerProviderBase } from '../OwnerProviderBase';\nimport { stringify } from '../../helpers/common';\n\n//Handles management of established connections\nexport class CircleNetworkProvider extends OwnerProviderBase {\n  private static instance: CircleNetworkProvider;\n  private root = '/circles/connections';\n\n  constructor(sharedSecret: Uint8Array | undefined) {\n    if (!sharedSecret) {\n      throw '[CircleNetworkProvider] Shared Secret is required';\n    }\n    super(sharedSecret);\n  }\n\n  async blockDotYouId(dotYouId: string): Promise<boolean> {\n    const client = super.createAxiosClient();\n    const url = this.root + '/block';\n\n    const data: DotYouIdRequest = { dotYouId: dotYouId };\n    return client\n      .post(url, data)\n      .then((response) => {\n        return response.data;\n      })\n      .catch(super.handleErrorResponse);\n  }\n\n  async disconnectFromContact(dotYouId: string): Promise<boolean> {\n    const client = super.createAxiosClient();\n    const url = this.root + '/disconnect';\n    const data: DotYouIdRequest = { dotYouId: dotYouId };\n    return client\n      .post(url, data)\n      .then((response) => {\n        return response.data;\n      })\n      .catch(super.handleErrorResponse);\n  }\n\n  async getConnections(data: PagingOptions): Promise<PagedResult<DotYouProfile>> {\n    const client = super.createAxiosClient();\n    const url = this.root + '/connected?' + stringify(data);\n    return client.post<PagedResult<DotYouProfile>>(url, data).then((response) => {\n      return response.data;\n    });\n  }\n\n  async getBlockedConnections(params: PagingOptions): Promise<PagedResult<DotYouProfile>> {\n    const client = super.createAxiosClient();\n    const url = this.root + '/blocked?' + stringify(params);\n    return client\n      .get(url)\n      .then((response) => {\n        return response.data;\n      })\n      .catch(super.handleErrorResponse);\n  }\n\n  getConnectionInfo(dotYouId: string, includeContactData = false): Promise<ConnectionInfo> {\n    const client = super.createAxiosClient();\n    const url = this.root + `/status?omitContactData=${!includeContactData}`;\n\n    const data: DotYouIdRequest = { dotYouId: dotYouId };\n    return client\n      .post(url, data)\n      .then((response) => {\n        return { ...response.data, status: response.data?.status?.toLowerCase() };\n      })\n      .catch(super.handleErrorResponse);\n  }\n  public static getInstance(sharedSecret): CircleNetworkProvider {\n    if (!CircleNetworkProvider.instance) {\n      CircleNetworkProvider.instance = new CircleNetworkProvider(sharedSecret);\n    }\n\n    return CircleNetworkProvider.instance;\n  }\n}\n","import {\n  ApiType,\n  DataUtil,\n  DriveProvider,\n  MediaProvider,\n  DriveSearchResult,\n  UploadFileMetadata,\n  UploadInstructionSet,\n  UploadResult,\n  SecurityGroupType,\n  CursoredResult,\n} from '@youfoundation/dotyoucore-js';\nimport { OwnerProviderBase } from '../OwnerProviderBase';\nimport { ContactConfig, ContactFile, RawContact } from './ContactTypes';\n\n//Handles management of Contacts\nexport class ContactProvider extends OwnerProviderBase {\n  private static instance: ContactProvider;\n  private _driveProvider: DriveProvider;\n  private _mediaProvider: MediaProvider;\n\n  constructor(sharedSecret: Uint8Array | undefined) {\n    if (!sharedSecret) {\n      throw '[ContactProvider] Shared Secret is required';\n    }\n    super(sharedSecret);\n\n    this._driveProvider = new DriveProvider({ api: ApiType.Owner, sharedSecret: sharedSecret });\n    this._mediaProvider = new MediaProvider({\n      api: ApiType.Owner,\n      sharedSecret: sharedSecret,\n      driveProvider: this._driveProvider,\n    });\n  }\n\n  async saveContact(contact: RawContact): Promise<ContactFile> {\n    if (contact.id) {\n      contact.fileId = (await this.getContactByUniqueId(contact.id))?.fileId;\n    }\n\n    if (!contact.fileId) {\n      const existingContact = await this.getContactByUniqueId(DataUtil.toGuidId(contact.dotYouId));\n\n      contact.id = existingContact?.id ?? DataUtil.getNewId();\n      contact.fileId = existingContact?.fileId ?? undefined;\n    }\n\n    // Save raw image:\n    if (contact.image?.content) {\n      contact.imageFileId = (\n        await this._mediaProvider.uploadImage(\n          ContactConfig.ContactTargetDrive,\n          undefined,\n          { requiredSecurityGroup: SecurityGroupType.Owner },\n          DataUtil.base64ToUint8Array(contact.image.content),\n          contact.imageFileId,\n          contact.image.contentType\n        )\n      ).fileId;\n      contact.image = undefined;\n    }\n\n    const encrypt = true;\n\n    const instructionSet: UploadInstructionSet = {\n      transferIv: this._driveProvider.Random16(),\n      storageOptions: {\n        overwriteFileId: contact?.fileId ?? '',\n        drive: ContactConfig.ContactTargetDrive,\n      },\n      transitOptions: null,\n    };\n\n    const payloadJson: string = DataUtil.JsonStringify64(contact as ContactFile);\n    const payloadBytes = DataUtil.stringToUint8Array(payloadJson);\n\n    const shouldEmbedContent = payloadBytes.length < 3000;\n    const metadata: UploadFileMetadata = {\n      contentType: 'application/json',\n      appData: {\n        tags: [contact.id, DataUtil.toGuidId(contact.dotYouId)],\n        fileType: ContactConfig.ContactFileType,\n        contentIsComplete: shouldEmbedContent,\n        jsonContent: shouldEmbedContent ? payloadJson : null,\n        // Having the dotYouId MD5 hashed as unique id, should avoid having duplicates getting created, enforced servers side;\n        uniqueId: contact.dotYouId ? DataUtil.toGuidId(contact.dotYouId) : contact.id,\n      },\n      payloadIsEncrypted: encrypt,\n    };\n\n    const result: UploadResult = await this._driveProvider.Upload(\n      instructionSet,\n      metadata,\n      payloadBytes,\n      undefined,\n      encrypt\n    );\n\n    //update server-side info\n    contact.fileId = result.file.fileId;\n    return contact;\n  }\n\n  async getContactByUniqueId(uniqueId: string): Promise<ContactFile> {\n    const response = await this._driveProvider.QueryBatch({\n      targetDrive: ContactConfig.ContactTargetDrive,\n      clientUniqueIdAtLeastOne: [uniqueId],\n    });\n\n    if (response.searchResults.length == 0) {\n      return;\n    }\n\n    if (response.searchResults.length > 1) {\n      console.warn('UniqueId [' + uniqueId + '] in contacts has more than one file. Using latest');\n    }\n\n    const dsr: DriveSearchResult = response.searchResults[0];\n    const contact: ContactFile = await this._driveProvider.GetPayload<ContactFile>(\n      ContactConfig.ContactTargetDrive,\n      dsr.fileId,\n      dsr.fileMetadata,\n      dsr.sharedSecretEncryptedKeyHeader,\n      response.includeMetadataHeader\n    );\n\n    // Set fileId for future replace\n    contact.fileId = dsr.fileId;\n\n    return contact;\n  }\n\n  async getContactByTag(tag: string): Promise<ContactFile> {\n    const response = await this._driveProvider.QueryBatch({\n      targetDrive: ContactConfig.ContactTargetDrive,\n      tagsMatchAtLeastOne: [tag],\n    });\n\n    if (response.searchResults.length == 0) {\n      return;\n    }\n\n    if (response.searchResults.length > 1) {\n      console.warn('Tag [' + tag + '] in contacts has more than one file. Using latest');\n    }\n\n    const dsr: DriveSearchResult = response.searchResults[0];\n    const contact: ContactFile = await this._driveProvider.GetPayload<ContactFile>(\n      ContactConfig.ContactTargetDrive,\n      dsr.fileId,\n      dsr.fileMetadata,\n      dsr.sharedSecretEncryptedKeyHeader,\n      response.includeMetadataHeader\n    );\n\n    // Set fileId for future replace\n    contact.fileId = dsr.fileId;\n\n    return contact;\n  }\n\n  async getContacts(\n    cursorState: string | undefined = undefined,\n    pageSize = 10\n  ): Promise<CursoredResult<ContactFile[]>> {\n    const response = await this._driveProvider.QueryBatch(\n      {\n        targetDrive: ContactConfig.ContactTargetDrive,\n        fileType: [ContactConfig.ContactFileType],\n      },\n      { maxRecords: pageSize, cursorState: cursorState, includeMetadataHeader: true }\n    );\n\n    if (response.searchResults.length == 0) {\n      return { results: [], cursorState: '' };\n    }\n\n    return {\n      results: await Promise.all(\n        response.searchResults.map(async (result) => {\n          const dsr: DriveSearchResult = result;\n          const contact: ContactFile = await this._driveProvider.GetPayload<ContactFile>(\n            ContactConfig.ContactTargetDrive,\n            dsr.fileId,\n            dsr.fileMetadata,\n            dsr.sharedSecretEncryptedKeyHeader,\n            response.includeMetadataHeader\n          );\n\n          // Set fileId for future replace\n          contact.fileId = dsr.fileId;\n\n          return contact;\n        })\n      ),\n      cursorState: response.cursorState,\n    };\n  }\n\n  public static getInstance(sharedSecret): ContactProvider {\n    if (!ContactProvider.instance) {\n      ContactProvider.instance = new ContactProvider(sharedSecret);\n    }\n\n    return ContactProvider.instance;\n  }\n}\n","import { DataUtil, TargetDrive, ThumbSize } from '@youfoundation/dotyoucore-js';\n\nexport class ContactConfig {\n  static readonly ContactDriveType: string = DataUtil.toGuidId('contact_drive_type');\n  static readonly ContactFileType: number = 100;\n\n  // System Drive (Alias and Type are static and will never change)\n  static readonly ContactTargetDrive: TargetDrive = {\n    alias: '2612429d1c3f037282b8d42fb2cc0499',\n    type: '70e92f0f94d05f5c7dcd36466094f3a5',\n  };\n}\n\nexport interface ContactDataImage extends ThumbSize {\n  content: string;\n  url?: string;\n}\n\nexport interface ContactFile {\n  // Meta data\n  dotYouId?: string;\n  id?: string;\n  fileId?: string;\n  source: 'contact' | 'pending' | 'public' | 'user';\n\n  // Contact data\n  name?: { givenName: string; surname: string };\n  location?: { city?: string; country?: string };\n  phone?: { number: string };\n  birthday?: { date: string };\n  imageFileId?: string;\n}\nexport interface RawContact extends ContactFile {\n  image?: ContactDataImage;\n}\n\nexport interface ContactVm {\n  id?: string;\n\n  name?: { givenName: string; surname: string };\n  location?: { city?: string; country?: string };\n  phone?: { number: string };\n  birthday?: { date: string };\n  imageFileId?: string;\n  imageUrl?: string;\n\n  dotYouId?: string;\n  source: 'contact' | 'pending' | 'public' | 'user';\n}\n","import { DataUtil, DriveSearchResult, TargetDrive, ThumbSize } from '@youfoundation/dotyoucore-js';\nimport { OwnerProviderBase } from '../OwnerProviderBase';\nimport TransitProvider from './TransitProvider';\n\ntype ThumbnailMeta = {\n  naturalSize: { width: number; height: number };\n  sizes?: ThumbSize[];\n  url: string;\n};\n\nexport class ExternalMediaProvider extends OwnerProviderBase {\n  private static instance: ExternalMediaProvider;\n  private transitProvider: TransitProvider;\n\n  constructor(sharedSecret: Uint8Array | undefined | null) {\n    super(sharedSecret);\n\n    this.transitProvider = TransitProvider.getInstance(sharedSecret);\n  }\n\n  async getDecryptedMetadata(\n    dotYouId: string,\n    targetDrive: TargetDrive,\n    fileId: string\n  ): Promise<DriveSearchResult> {\n    return await this.transitProvider.GetFileHeader(dotYouId, targetDrive, fileId);\n  }\n\n  async getDecryptedThumbnailMeta(\n    dotYouId: string,\n    targetDrive: TargetDrive,\n    fileId: string\n  ): Promise<ThumbnailMeta | undefined> {\n    //it seems these will be fine for images but for video and audio we must stream decrypt\n    return this.getDecryptedMetadata(dotYouId, targetDrive, fileId).then((header) => {\n      if (!header.fileMetadata.appData.previewThumbnail) {\n        return;\n      }\n\n      const previewThumbnail = header.fileMetadata.appData.previewThumbnail;\n      const buffer = DataUtil.base64ToUint8Array(previewThumbnail.content);\n      const url = window.URL.createObjectURL(\n        new Blob([buffer], { type: previewThumbnail.contentType })\n      );\n\n      return {\n        naturalSize: { width: previewThumbnail.pixelWidth, height: previewThumbnail.pixelHeight },\n        sizes: header.fileMetadata.appData.additionalThumbnails ?? [],\n        url: url,\n      };\n    });\n  }\n\n  // Retrieves an image/thumb, decrypts, then returns a url to be passed to an image control\n  async getDecryptedImageUrl(\n    dotYouId: string,\n    targetDrive: TargetDrive,\n    fileId: string,\n    size?: ThumbSize\n  ): Promise<string> {\n    return this.getDecryptedImageData(dotYouId, targetDrive, fileId, size).then((data) => {\n      const url = window.URL.createObjectURL(new Blob([data.content], { type: data.contentType }));\n      return url;\n    });\n  }\n\n  async getDecryptedImageData(\n    dotYouId: string,\n    targetDrive: TargetDrive,\n    fileId: string,\n    size?: ThumbSize\n  ): Promise<{\n    pixelHeight: number;\n    pixelWidth: number;\n    contentType: string;\n    content: ArrayBuffer;\n  }> {\n    const header = await this.transitProvider.GetFileHeader(dotYouId, targetDrive, fileId);\n    const keyHeader = header.fileMetadata.payloadIsEncrypted\n      ? await this.transitProvider.DecryptKeyHeader(header.sharedSecretEncryptedKeyHeader)\n      : undefined;\n\n    const bytesPromise = size\n      ? this.transitProvider.GetThumbBytes(\n          dotYouId,\n          targetDrive,\n          fileId,\n          keyHeader,\n          size.pixelWidth,\n          size.pixelHeight\n        )\n      : this.transitProvider.GetPayloadBytes(dotYouId, targetDrive, fileId, keyHeader);\n    //: this.transitProvider.GetPayloadBytesNoPriorHeader(dotYouId, targetDrive, fileId);\n\n    return {\n      pixelHeight: header.fileMetadata.appData.previewThumbnail?.pixelHeight ?? 0,\n      pixelWidth: header.fileMetadata.appData.previewThumbnail?.pixelWidth ?? 0,\n      contentType: header.fileMetadata.appData.previewThumbnail?.contentType ?? '',\n      content: await bytesPromise,\n    };\n  }\n\n  public static getInstance(sharedSecret): ExternalMediaProvider {\n    if (!ExternalMediaProvider.instance) {\n      ExternalMediaProvider.instance = new ExternalMediaProvider(sharedSecret);\n    }\n\n    return ExternalMediaProvider.instance;\n  }\n}\n","import {\n  ApiType,\n  FileQueryParams,\n  GetBatchQueryResultOptions,\n  QueryBatchResponse,\n  TargetDrive,\n  KeyHeader,\n  EncryptedKeyHeader,\n  FileMetadata,\n  DriveProvider,\n  DataUtil,\n  DriveSearchResult,\n  AesEncrypt,\n} from '@youfoundation/dotyoucore-js';\nimport { AxiosRequestConfig } from 'axios';\nimport { OwnerProviderBase } from '../OwnerProviderBase';\n\ninterface TransitProviderOptions {\n  driveProvider: DriveProvider;\n  sharedSecret: Uint8Array | undefined | null;\n}\n\ninterface GetFileRequest {\n  dotYouId: string;\n  file: {\n    targetDrive: TargetDrive;\n    fileId: string;\n  };\n}\n\ninterface TransitQueryBatchRequest {\n  queryParams: FileQueryParams;\n  resultOptionsRequest: GetBatchQueryResultOptions;\n  dotYouId: string;\n}\n\nconst _internalMetadataCache = new Map<string, Promise<DriveSearchResult>>();\n\nexport default class TransitProvider extends OwnerProviderBase {\n  private static instance: TransitProvider;\n  private driveProvider: DriveProvider;\n\n  constructor(options: TransitProviderOptions) {\n    super(options.sharedSecret);\n\n    this.driveProvider = options.driveProvider;\n  }\n\n  async QueryBatch(\n    dotYouId: string,\n    params: FileQueryParams,\n    ro?: GetBatchQueryResultOptions\n  ): Promise<QueryBatchResponse> {\n    const client = this.createAxiosClient();\n\n    if (!ro) {\n      ro = {\n        cursorState: undefined,\n        maxRecords: 10,\n        includeMetadataHeader: true,\n      };\n    }\n\n    const request: TransitQueryBatchRequest = {\n      queryParams: params,\n      resultOptionsRequest: ro,\n      dotYouId: dotYouId,\n    };\n\n    return client.post<QueryBatchResponse>('/transit/query/batch', request).then((response) => {\n      return response.data;\n    });\n  }\n\n  async GetPayload<T>(\n    dotYouId: string,\n    targetDrive: TargetDrive,\n    fileId: string,\n    fileMetadata: FileMetadata,\n    sharedSecretEncryptedKeyHeader: EncryptedKeyHeader,\n    includesJsonContent: boolean\n  ): Promise<T> {\n    const keyheader = fileMetadata.payloadIsEncrypted\n      ? await this.DecryptKeyHeader(sharedSecretEncryptedKeyHeader)\n      : undefined;\n\n    if (fileMetadata.appData.contentIsComplete && includesJsonContent) {\n      return await this.driveProvider.DecryptJsonContent<T>(fileMetadata, keyheader);\n    } else {\n      return await this.GetPayloadAsJson<T>(dotYouId, targetDrive, fileId, keyheader);\n    }\n  }\n\n  async GetPayloadAsJson<T>(\n    dotYouId: string,\n    targetDrive: TargetDrive,\n    fileId: string,\n    keyHeader: KeyHeader | undefined\n  ): Promise<T> {\n    return this.GetPayloadBytes(dotYouId, targetDrive, fileId, keyHeader).then((bytes) => {\n      const json = DataUtil.byteArrayToString(new Uint8Array(bytes));\n      try {\n        const o = JSON.parse(json);\n        return o;\n      } catch (ex) {\n        console.warn('base JSON.parse failed');\n        const replaceAll = (str: string, find: string, replace: string) => {\n          return str.replace(new RegExp(find, 'g'), replace);\n        };\n\n        const jsonWithRemovedQuote = replaceAll(json, '\\u0019', '');\n        const jsonWithRemovedEmDash = replaceAll(jsonWithRemovedQuote, '\\u0014', '');\n\n        const o = JSON.parse(jsonWithRemovedEmDash);\n\n        console.warn('... but we fixed it');\n        return o;\n      }\n    });\n  }\n\n  async GetPayloadBytesNoPriorHeader(\n    dotYouId: string,\n    targetDrive: TargetDrive,\n    fileId: string\n  ): Promise<ArrayBuffer> {\n    const client = this.createAxiosClient();\n\n    const request: GetFileRequest = {\n      dotYouId: dotYouId,\n      file: {\n        targetDrive: targetDrive,\n        fileId: fileId,\n      },\n    };\n\n    const config: AxiosRequestConfig = {\n      responseType: 'arraybuffer',\n    };\n\n    return client\n      .post('/transit/query/payload', request, config)\n      .then(async (response) => {\n        const isEncrypted = response.headers.payloadencrypted === 'True';\n        if (isEncrypted) {\n          const sharedSecretEncryptedKeyHeader64 = DataUtil.base64ToUint8Array(\n            response.headers.sharedsecretencryptedheader64\n          );\n\n          console.log(response);\n          const iv = DataUtil.base64ToUint8Array(response.data.iv);\n          console.log({ iv });\n          const bytes = await AesEncrypt.CbcDecrypt(\n            sharedSecretEncryptedKeyHeader64,\n            iv,\n            this.getSharedSecret()\n          );\n          console.log(bytes);\n        }\n        // if (keyHeader) {\n        //   const cipher = new Uint8Array(response.data);\n        //   return this.driveProvider.DecryptUsingKeyHeader(cipher, keyHeader).then((bytes) => {\n        //     return bytes;\n        //   });\n        // } else {\n        return new Uint8Array(response.data);\n        // }\n      })\n      .catch((error) => {\n        console.error(error);\n        throw error;\n      });\n  }\n\n  async GetPayloadBytes(\n    dotYouId: string,\n    targetDrive: TargetDrive,\n    fileId: string,\n    keyHeader: KeyHeader | undefined\n  ): Promise<ArrayBuffer> {\n    const client = this.createAxiosClient();\n\n    const request: GetFileRequest = {\n      dotYouId: dotYouId,\n      file: {\n        targetDrive: targetDrive,\n        fileId: fileId,\n      },\n    };\n\n    const config: AxiosRequestConfig = {\n      responseType: 'arraybuffer',\n    };\n\n    return client\n      .post('/transit/query/payload', request, config)\n      .then((response) => {\n        if (keyHeader) {\n          const cipher = new Uint8Array(response.data);\n          return this.driveProvider.DecryptUsingKeyHeader(cipher, keyHeader).then((bytes) => {\n            return bytes;\n          });\n        } else {\n          return new Uint8Array(response.data);\n        }\n      })\n      .catch((error) => {\n        console.error(error);\n        throw error;\n      });\n  }\n\n  async GetThumbBytes(\n    dotYouId: string,\n    targetDrive: TargetDrive,\n    fileId: string,\n    keyHeader: KeyHeader | undefined,\n    width: number,\n    height: number\n  ): Promise<ArrayBuffer> {\n    const client = this.createAxiosClient();\n    const request: GetFileRequest = {\n      dotYouId: dotYouId,\n      file: {\n        targetDrive: targetDrive,\n        fileId: fileId,\n      },\n    };\n    const config: AxiosRequestConfig = {\n      responseType: 'arraybuffer',\n    };\n\n    return client\n      .post('/transit/query/thumb', { ...request, width: width, height: height }, config)\n      .then((response) => {\n        if (keyHeader) {\n          const cipher = new Uint8Array(response.data);\n          return this.driveProvider.DecryptUsingKeyHeader(cipher, keyHeader).then((bytes) => {\n            return bytes;\n          });\n        } else {\n          return new Uint8Array(response.data);\n        }\n      })\n      .catch((error) => {\n        // console.error(error);\n        throw error;\n      });\n  }\n\n  async GetFileHeader(\n    dotYouId: string,\n    targetDrive: TargetDrive,\n    fileId: string\n  ): Promise<DriveSearchResult> {\n    const cacheKey = `${dotYouId}+${targetDrive.alias}-${targetDrive.type}+${fileId}`;\n    if (_internalMetadataCache.has(cacheKey)) {\n      return await _internalMetadataCache.get(cacheKey);\n    }\n\n    const client = this.createAxiosClient();\n\n    const request: GetFileRequest = {\n      dotYouId: dotYouId,\n      file: {\n        targetDrive: targetDrive,\n        fileId: fileId,\n      },\n    };\n\n    const promise = client\n      .post('/transit/query/header', request)\n      .then((response) => {\n        return response.data as DriveSearchResult;\n      })\n      .catch((error) => {\n        //TODO: Handle this - the file was not uploaded\n        console.error(error);\n        throw error;\n      });\n\n    _internalMetadataCache.set(cacheKey, promise);\n\n    return promise;\n  }\n\n  async DecryptKeyHeader(encryptedKeyHeader: EncryptedKeyHeader): Promise<KeyHeader> {\n    return await this.driveProvider.DecryptKeyHeader(encryptedKeyHeader);\n  }\n\n  public static getInstance(sharedSecret): TransitProvider {\n    if (!TransitProvider.instance) {\n      const driveProvider = new DriveProvider({ api: ApiType.Owner, sharedSecret: sharedSecret });\n\n      TransitProvider.instance = new TransitProvider({\n        sharedSecret: sharedSecret,\n        driveProvider: driveProvider,\n      });\n    }\n\n    return TransitProvider.instance;\n  }\n}\n"],"names":["ExternalDataProvider","sharedSecret","transitProvider","TransitProvider","dotYouId","attributeType","profileId","BuiltInProfiles","targetDrive","getTargetDriveFromProfileId","queryParams","fileType","AttributeConfig","tagsMatchAll","undefined","this","QueryBatch","result","searchResults","sort","a","b","priority","Promise","all","map","dsr","attr","id","type","sectionId","data","acl","serverMetadata","accessControlList","GetPayload","fileId","fileMetadata","sharedSecretEncryptedKeyHeader","includeMetadataHeader","attrPayLoad","filter","item","instance","OwnerProviderBase","ContactSourceProvider","externalDataProvider","externalMediaProvider","circleNetworkProvider","circleNetworkRequestProvider","getInstance","CircleNetworkProvider","CircleNetworkRequestProvider","ExternalMediaProvider","getConnectionInfo","queryConnectionAttributes","connectionContactData","contactFromTransit","originalContactData","givenName","surname","getPhotoDataFromPublic","imageId","name","image","source","getProfileAttributes","AttributeDefinitions","phone","location","birthday","photo","MinimalProfileFields","city","LocationFields","country","number","PhoneFields","date","BirthdayFields","queryConnectionPhotoData","profileImageId","getDecryptedImageData","imageData","pixelWidth","pixelHeight","contentType","content","DataUtil","Uint8Array","loadPendingProfilePicture","getPendingRequest","pendingContactData","senderDotYouId","contactData","client","PublicClient","api","ApiType","root","fileReadOnlyProvider","GetFile","rawData","nameAttr","get","photoRefAttr","photoFile","payload","previewThumbnail","additionalThumbnails","reduce","prevVal","curValue","header","appData","toString","imageFileId","photoData","parseContact","contact","imageUrl","buffer","window","URL","createObjectURL","Blob","getSharedSecret","useAuth","contactProvider","ContactProvider","contactSourceProvider","queryClient","useQueryClient","fetchSingle","getContactByUniqueId","directContact","contactBookContact","fetchConnectionInfo","connectionInfo","saveContact","connectionContact","console","debug","returnContact","fetchPendingInfo","pendingInfo","fetchDataFromPublic","publicContact","savedReturnedContact","refresh","warn","newContact","fetch","useQuery","refetchOnWindowFocus","onError","err","error","retry","useMutation","onMutate","cancelQueries","previousContact","getQueryData","setQueryData","_newAttr","context","onSettled","invalidateQueries","url","post","then","response","catch","stringify","params","includeContactData","status","toLowerCase","_driveProvider","_mediaProvider","DriveProvider","MediaProvider","driveProvider","existingContact","uploadImage","ContactConfig","requiredSecurityGroup","SecurityGroupType","instructionSet","transferIv","Random16","storageOptions","overwriteFileId","drive","transitOptions","payloadJson","payloadBytes","shouldEmbedContent","length","metadata","tags","contentIsComplete","jsonContent","uniqueId","payloadIsEncrypted","Upload","file","clientUniqueIdAtLeastOne","tag","tagsMatchAtLeastOne","cursorState","pageSize","maxRecords","results","ContactDriveType","ContactFileType","ContactTargetDrive","alias","GetFileHeader","getDecryptedMetadata","naturalSize","width","height","sizes","size","DecryptKeyHeader","keyHeader","bytesPromise","GetThumbBytes","GetPayloadBytes","_internalMetadataCache","Map","options","ro","createAxiosClient","request","resultOptionsRequest","includesJsonContent","keyheader","DecryptJsonContent","GetPayloadAsJson","bytes","json","JSON","parse","ex","replaceAll","str","find","replace","RegExp","jsonWithRemovedQuote","jsonWithRemovedEmDash","o","config","responseType","headers","payloadencrypted","sharedSecretEncryptedKeyHeader64","sharedsecretencryptedheader64","log","iv","AesEncrypt","cipher","DecryptUsingKeyHeader","cacheKey","has","promise","set","encryptedKeyHeader"],"sourceRoot":""}